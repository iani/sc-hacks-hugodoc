#+TITLE: Registry: Hierarchical Namespaces
#+CATEGORIES: classes
#+TAGS: registry

This class helps to store objects and to retrieve them using a key.  This is similar to the way that with classes such as =Pdef=, =Ndef=, =OSCdef= work, but =Registry= can be used to add the same feature to any class, without subclassing it.  To create this behavior instead, add a method to =Symbol= for accessing the kind of object needed.  For example: =\aSymbol.oscFunc=. This also allows easier customization of how the object is created if not found. 

#+HTML: <!-- more -->

* How it works

Store an object in Library under an array of objects (called a /path/).  When accessing the path, create the object if not already stored, else return the previously stored object.

* Who uses it

- =SynthPlayer= registers its instances in the current environment under their names.
- 
- =Function:oscFunc= and =Symbol:removeOsc= registers =OSCFuncs= under their path names in order to remove existing OSCFunc instances when creating a new one under the same path. 

* Example

This is the code that makes it possible to create or modify an OSCFunc bound to a symbol.  It defines the methods =Function:oscFunc= and =Symbol:removeOsc=.

#+BEGIN_SRC sclang
+ Function {
	oscFunc { | path |
		path.removeOsc;
		^Registry ('oscFuncs', path, { OSCFunc (this, path) });
	}
}

+ Symbol {
	removeOsc {
		Registry.doIfFound ('oscFuncs', this, { | found |
			found.objectClosed;
			found.free;
		});	
	}
}
#+END_SRC
