[
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/principles/",
	"title": "Fundamental Techniques",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/",
	"title": "Principles",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/foundation-classes/",
	"title": "Foundation Classes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/overviews/",
	"title": "Overviews",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/synths/",
	"title": "Synths",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/patterns/",
	"title": "Patterns",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/gui/",
	"title": "GUI",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/use-scenarios/",
	"title": "Use Scenarios",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/exploring-techniques/",
	"title": "Exploring Techniques",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tests/",
	"title": "Tests",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/",
	"title": "HOME",
	"tags": [],
	"description": "",
	"content": "This site documents the sc-hacks library.\nIt is made with hugo using the docdock theme.\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/_header/",
	"title": "header",
	"tags": [],
	"description": "",
	"content": "sc-hacks Documentation\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/gui/buildingguis/",
	"title": "Building GUIs",
	"tags": ["learning,", "gui"],
	"description": "",
	"content": "This notebook shows how to build GUIs starting from scratch, with minimal code and in small steps.\nJust a window //: 1 Just a window Window (\u0026quot;window name\u0026quot;).front;  Add a slider and resize. Use VLayout for automatic resizing.\nWindow (\u0026quot;window name\u0026quot;) .view.layout_ ( VLayout ( Slider () ) ).front; //: Make the slider horizontal. Window (\u0026quot;window name\u0026quot;) .view.layout_ ( VLayout ( Slider () .orientation_ (\\horizontal) ) ).front;  Add more sliders Use a function to avoid repeating spec code! Make the orientation an argument to enable customization.\nvar makeSlider; makeSlider = { | orientation = \\horizontal | Slider () .orientation_ (orientation) }; Window (\u0026quot;window name\u0026quot;) .view.layout_ ( VLayout ( *({makeSlider.([\\horizontal, \\vertical].choose)} ! 10) ) ).front;  Add more arguments for controlSpec, label, and action var makeSlider; makeSlider = { | label = \u0026quot;slider\u0026quot;, min = 0, max = 10, step = 0, default = 0.5, orientation = \\horizontal, action | var controlSpec; controlSpec = [min, max, \\lin, step, default].asSpec; // provide default action if needed: action ?? { action = { | value | controlSpec.map (value).postln } }; HLayout ( StaticText ().string_ (label), Slider () .action_ ({ | me | action.(me.value)}) .orientation_ (orientation) ) }; Window (\u0026quot;window name\u0026quot;) .view.layout_ ( VLayout ( *({makeSlider.([\\horizontal, \\vertical].choose)} ! 10) ) ).front;  Add number box, after the slider. var makeSlider; makeSlider = { | label = \u0026quot;slider\u0026quot;, min = 0, max = 10, step = 0, default = 0.5, orientation = \\horizontal, action | var controlSpec; controlSpec = [min, max, \\lin, step, default].asSpec; // provide default action if needed: action ?? { action = { | value | controlSpec.map (value).postln } }; HLayout ( StaticText ().string_ (label), Slider () .action_ ({ | me | action.(me.value)}) .orientation_ (orientation), NumberBox ()) }; Window (\u0026quot;window name\u0026quot;) .view.layout_ ( VLayout ( *({makeSlider.( max: 0.0.rrand (20.0), orientation: [\\horizontal, \\vertical].choose)} ! 10) ) ).front;  Add value update for number box and slider  var makeSlider; makeSlider = { | label = \u0026quot;slider\u0026quot;, min = 0, max = 10, step = 0, default = 0.5, orientation = \\horizontal, action | var controlSpec, mappedVal, slider, numberBox; controlSpec = [min, max, \\lin, step, default].asSpec; // provide default action if needed: action ?? { action = { | value | value.postln } }; HLayout ( StaticText ().string_ (label), slider = Slider () .action_ ({ | me | mappedVal = controlSpec.map (me.value); numberBox.value = mappedVal; action.(mappedVal)}) .orientation_ (orientation), numberBox = NumberBox () .action_ ({ | me | mappedVal = me.value; slider.value = controlSpec.unmap (mappedVal); action.(mappedVal) }) ) }; Window (\u0026quot;window name\u0026quot;) .view.layout_ ( VLayout ( *({ | i | makeSlider.(format (\u0026quot;slider %\u0026quot;, i), max: 0.0.rrand (20.0), orientation: [\\horizontal, \\vertical].choose) } ! 10) ) ).front;  Group the controlSpec arguments to make them more compact Also initialize the values of gui elements\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/class/",
	"title": "Class",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/classes/",
	"title": "Classes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/coding/",
	"title": "Coding",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/coding/",
	"title": "Coding",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/gui/creatingguis/",
	"title": "Creating GUIs",
	"tags": ["gui,", "window"],
	"description": "",
	"content": "This library provides utilities for creating GUI elements and connecting them to both patterns and synths. Here are some examples.\nWindows Sliders Buttons "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/data/",
	"title": "Data",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/env/",
	"title": "Env",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/envelopes/",
	"title": "Envelopes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/envgen/",
	"title": "Envgen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/environment/",
	"title": "Environment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/event/",
	"title": "Event",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/eventpattern/",
	"title": "Eventpattern",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/eventstream/",
	"title": "Eventstream",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/eventstreamplayer/",
	"title": "Eventstreamplayer",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/gate/",
	"title": "Gate",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/grains/",
	"title": "Grains",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/granular/",
	"title": "Granular",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/gui/",
	"title": "Gui",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/gui/",
	"title": "Gui",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tests/mermaid-test/",
	"title": "HUGO docdock - Easy diagrams",
	"tags": [],
	"description": "",
	"content": " Some demos The following diagrams are produced by the mermaid tool, just by some simple code as shown below. No plugins required. Use docdock theme with hugo.\nDemo 1 - simple flow chart   Unfold to see code   Code:\ngraph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two]    graph LR; A[Hard edge] --|Link text| B(Round edge) B -- C{Decision} C --|One| D[Result one] C --|Two| E[Result two] \nDemo 2 - gantt   Unfold to see code   Code:\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h    gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h \n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/synths/improvingeplay/",
	"title": "Improving Function:eplay",
	"tags": ["design,", "synth,", "TODO"],
	"description": "",
	"content": "Individual improvement steps for Function:eplay: Done and TODO. Thesse notes are from an early stage in development. Now the functionality of most done steps has been integrated in class SynthPlayer.\nDone (11 Jun 2017 21:48)  Store the resulting synth in envir under [\\synths, synthName] (default for synthName=: =synth). If previous synth exists under [\\synths, synthName] path, then free/release it. When a synth ends, remove it from its path in envir. Make sure that when a synth previousSynth is released by replacing it through a new synth created through Function:eplay, the previousSynth ending does not remove the new synth that has already been stored in the same path. Notification actions for updates from enviroment variable changes are added when the Synth starts (not when the Function:play message is sent). This way, there are no more errors \"Node not found\" when changing the environment before the synth has started.  Done (19 Jun 2017 10:52): Synth start-stop (release) and set control from Event:eplay (EventPatterns) The following will add some complexity to the current scheme and may therefore be added later on only.\n Define SynthPlayer to add synth start-stop capabilities to Function:eplay Add synths instance variable to Nevent for faster access to SynthPlayers  In addition to listening for changes from the currentEnvironment, a second notification mechanism should be added to Function:eplay, to enable creating new synths, releasing or freeing this synth when playing EventPatterns with an EventStreamPlayer. A simple way to do this is by a stream which generates the commands to be played. The stream is stored in a key with the same name as the synth to be controlled. Function:eplay or SynthPlayer:play adds the environment as notifier to the synth with the synth's name as message and a switch statement which choses the action to be performed depending on the value that was sent in addition to the key (message) by the changed message. A draft for this code has been added now to Function:eplay:\nsynth.onStart (this, {| myself | // \u0026quot;Synth started, so I add notifiers for updates\u0026quot;.postln; argNames do: { | param | synth.addNotifier (envir, param, { | val | synth.set (param, val); }); // Experimental: synth.addNotifier (envir, name, { | command | //\tcommand.postln; switch (command, \\stop, { synth.objectClosed; synth.release (envir [\\releaseTime] ? 0.02); }, { postf (\u0026quot;the command was: %\\n\u0026quot;, command)} ) }) }; });  Still TODO (19 Jun 2017 10:52) Synth start-stop notifications for GUI and other listeners  When a new synth starts or when an old synth is removed, it should emit notifications so that GUIS that depend on it update their status. Such guis may be: Start-stop buttons Guis with widgets for controlling the synths parameters. When a new synth starts, then the old gui should be replaced with a new one with widgets corresponding to the new synth's control parameters. Note: Possibly the notification should be emitted from the =\\synthName= under which the synth is stored. The messages may be: \\started \\stopped \\replaced The above is subject to testing.  Notes  When this is done, it should be possible to create multiple gui windows for multiple synths running in the same environment. However, parameters under the same name will control the parameters under that name for all synths in that environment. To develop the right code for this, do it with a plain function, adding the functionalities one-by-one.  Current Function:eplay method code Drafts See https://github.com/iani/sc-hacks/blob/master/LabCode/rebuildFunctionEplay.scd for draft used to build this functionality in SynthPlayer\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/language/",
	"title": "Language",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/learning/",
	"title": "Learning",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/method/",
	"title": "Method",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/methods/",
	"title": "Methods",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/overviews/minilanguageoverview/",
	"title": "Mini-Language Overview",
	"tags": ["class,", "method,", "coding,", "language"],
	"description": "",
	"content": "The classes, methods and operators provided by sc-hacks extend SuperCollider to simplify the coding of GUI and of sound / musical structure / interaction. They are designed in the sense of a very small language. Here is a summary.\nItems connected to currentEnvironment: GUI, Synths, Patterns, Routines Operator and message overview This is a draft: Implementation of the following operators has just started. The purpose of the overview is to guide coding by keeping the different versions discrete and consistent.\nOperators on Functions These are operators that are written after a function, and thus take a function as receiver. They serve two main uses of functions in musical processes:\n Play a synth (Function:play : operator +\u0026gt;) Play a routine (Function:fork : operator *\u0026gt;)  + play as synth\n* play as routine (fork)\nOperators on Events These are operators that are written after an event, and thus take an event as receiver. They serve to play the event as EventPattern inside currentEnvironment, setting the environments keys (but not producing any sound by itself). Furthermore, they serve to modify the event of such a playing EventPattern.\n@ play\n@+ addEvent\n@! setEvent\n@@ addKey\nOperators on Symbols These are operators that are written after a symbol, and thus take a symbol as receiver.\nThey are primarily used to link synths (with buses, and in right synth order).\n \u0026amp;\u0026gt; set the output bus of the receiver to the input bus of the argument (only the output bus of the receiver changes) \u0026lt;\u0026amp; set the input bus of the argument to the output bus of the receiver (only the input bus of the argument changes)  receiver \u0026amp;\u0026gt;! argument   \u0026amp;\u0026gt;! set the output bus of the receiver to the input bus of the argument, on a new private bus (both receiver and argument change)  receiver \u0026amp;/\u0026gt; argument   \u0026amp;/\u0026gt; Copy the output signal of the receiver from its bus onto the input bus of the argument, using a signal copy synth.  receiver \u0026lt;/\u0026gt; argument   \u0026lt;/\u0026gt; Copy the output signal of the receiver onto a new private bus, and the signal from that private bus onto the input bus of the argument, using 2 signal copy synths.  Messages to symbols splay\neplay\nrplay\nOperators on strings (!?) string + symbol : play synthdef named by string on the symbol as SynthPlayer ?\nPlaying Synths Playing Routines Playing patterns with default note events Playing patterns in currentEnvironment Creating GUIs "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/patterns/eventstream/",
	"title": "Modify Patterns while playing",
	"tags": ["EventStream,", "EventPattern,", "EventStreamPlayer"],
	"description": "",
	"content": "An EventStream makes it easy to modify patterns while playing them.\nHow it works An EventPattern creates EventStreams which are played by EventStreamPlayer. EventStream stores an event whose values are streams and uses this to produce a new event which is played by EventStreamPlayer. It is thus possible to modify the event stored in the EventStream while the EventStreamPlayer is playing it. This makes it easy to modify a playing pattern (which is difficult when using Pbind).\nExample  () +\u0026gt; \\e; 0.1 +\u0026gt;.dur \\e; Pseq ((0..20), inf) +\u0026gt;.degree \\e; Prand ((0..20), inf) +\u0026gt;.degree \\e; (freq: Pfunc ({ 300 rrand: 1000 }), dur: Prand ([0.1, 0.2], inf)) +\u0026gt; \\e; (freq: Pfunc ({ 30.rrand(80).midicps }), dur: Pfunc ({ 0.1 exprand: 1 }), legato: Prand ([0.1, 2], inf)) +\u0026gt; \\e; (degree: Pseq ((0..20), inf), dur: 0.1) +!\u0026gt;.degree \\e;  Note:\n +\u0026gt; adds all key-value pairs of an event to the event being played. +!\u0026gt; replaces the contents of the event being played by the contents of the new event.  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/foundation-classes/nevent/",
	"title": "Nevent: Environment that notifes variable updates",
	"tags": ["notification"],
	"description": "",
	"content": "Nevent is an EnvironmentRedirect that notifies the changes of value of its variables.\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/notes/",
	"title": "Notes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/notification/",
	"title": "Notification",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/foundation-classes/notification/",
	"title": "Notification: Register a function callback to a message and a pair of objects",
	"tags": ["Notification"],
	"description": "",
	"content": "Notification is an improved version of the NotificationCenter class. This class enables objects to register a function which is called when another object changes according to some aspect. The aspect is expressed by a symbol. To trigger a notification action, one sends the message changed to an object together with a symbol expressing the aspect which changed. The function will only be evaluated for those objects which have registered to listen to the changing object according to the given aspect symbol. This allows detailed control of callback execution amongst objects of the system. For example, one can tell a gui object to change its color to green when a synth starts, and to change its color to red when that synth stops.\n =Notification= adds the following enhancements: Ability to remove existing notification connections reliably. Several methods for easily adding or modifying connections between objects. Ability to remove all connections from an object with a single message, objectClosed, and also to execute additional actions when that object closes. Closing here means that the object is freed and will no longer be used by the system.  Examples onObjectClosed Registry uses onObjectClosed to remove objects by sending them that message:\n*new { | ... pathAndFunc | var path, makeFunc, instance; makeFunc = pathAndFunc.last; path = pathAndFunc[0..pathAndFunc.size-2]; instance = Library.global.atPath(path); if (instance.isNil) { instance = makeFunc.value; Library.global.putAtPath(path, instance); instance.onObjectClosed(this, { this.remove(*path) }); }; ^instance; }  addNotifierOneShot This is in turn used by oscFunc and rout methods for removing OSCFunc and Routine objects in order to replace them with new instances.\nThe addNotifierOneShot method executes the registered Function just once. This is useful when it is clear that only one call is required. For example, the onEnd and onStart methods for Node make use of the addNotifierOneShot method:\n+ Node { onStart { | listener, action | NodeWatcher.register(this); listener.addNotifierOneShot(this, \\n_go, action); } onEnd { | listener, action | NodeWatcher.register(this); //\tthis.isPlaying = true; // dangerous listener.addNotifierOneShot(this, \\n_end, action); } }  Similar extensions can be built for whatever object needs to monitor the closing or end of an object such as closing of a Window or stopping of a Pattern.\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/overviews/operatordesign/",
	"title": "Operator Overview",
	"tags": ["operators"],
	"description": "",
	"content": "sc-hacks uses binary operators to shorten and help classify the coding of common operations such as playing a synth or a pattern. The syntax of a binary operator in SuperCollider is:\nreceiver operator[optional: .adverb] argument  For example:\n// receiver operator adverb argument { WhiteNoise.ar(0.1) } +\u0026gt;.newenvir \\mysynth  Here is a list of operators introduced in sc-hacks.\nList of Operators Planned are 4 operators taking functions as argument, 4 operators taking event as argument, and 5 operators taking a symbol as argument. Currently (26 Jun 2017 08:57) the 8 first operators have been tested.\n { function } +\u0026gt; synthname  play as synth { function } *\u0026gt; synthname play as routine (fork) { function } **\u0026gt; synthname wrap in loop and play as routine (fork) { function } \u0026lt;* key evaluate function whenever value of key is set in envir ( event ) @\u0026gt; patternname play ( event ) @\u0026gt;+ patternname addEvent ( event ) @\u0026gt;! patternname setEvent ( event ) \u0026lt;@ key play next event from EventStream created from event, whenever value of key is set in envir. receiver \u0026amp;\u0026gt; argument set the output bus of the receiver to the input bus of the argument (only the output bus of the receiver changes) receiver \u0026lt;\u0026amp; argument set the input bus of the argument to the output bus of the receiver (only the input bus of the argument changes) receiver \u0026amp;\u0026gt;! argument set the output bus of the receiver to the input bus of the argument, - on a new private bus (both receiver and argument change) receiver \u0026amp;/\u0026gt; argument Copy the output signal of the receiver from its bus onto the input bus of the argument, using a signal copy synth. (neither receiver nor argument changes). receiver \u0026lt;/\u0026gt; argument Copy the output signal of the receiver onto a new private bus, and the signal from that private bus onto the input bus of the argument, using 2 signal copy synths (neither receiver nor argument changes).  Examples // ================================================================ // ================ Routines //: Start a routine { loop { ~freq = 500 rrand: 4000; 1.wait; } } *\u0026gt; \\rout1 //: replace this with a different routine { loop { ~freq = 100 rrand: 400; 0.2.exprand (0.5).wait; } } *\u0026gt; \\rout1 //: Shortcut for loop {} { ~freq = 50 exprand: 400; 0.1.wait; } **\u0026gt; \\rout1; //: stop the routine \\rout1.routine.stop; // ================================================================ // ================ Patterns //: start a new pattern (dur: 0.1, degree: Pseq ((0..7), inf)) @\u0026gt; \\pat1; //: replace the pattern running at \\pat1 with a new one (dur: Pwhite (0.01, 0.1, inf), degree: Pwhite(0, 7, inf)) @\u0026gt; \\pat1; //: add event's contents to the playing event (dur: Pwhite (0.01, 2.1, inf)) @\u0026gt;+ \\pat1; //: testing function in event key // Defer runs the function after the event has played all parameters (func1: {{ postf(\u0026quot;freq param is: %\\n\u0026quot;, ~freq )}.defer }) @\u0026gt;+ \\pat1; //: ================================================================ //: ================ More function operators //: Testing function in envir { | freq | { SinOsc.ar(freq, 0, EnvGen.kr(Env.perc(0.01, 0.1, 0.1)))}.play } \u0026lt;* \\freq; //: ========== Polyphony: EventStreams triggered by a pattern playing in currentEnvironment () @\u0026gt; \\pat1; // { ~freq.postln; } \u0026lt;* \\freq; // just as a test; (degree: Pseq((0..7), inf)) \u0026lt;@ \\freq; //: add another stream on a different label (degree: Pseq((0..7).scramble, inf)) \u0026lt;@.label2 \\freq; //: add another stream on a different label yet (degree: Pseq((0..7) + 10, inf), dur: 0.1) \u0026lt;@.label3 \\freq; //:  Additional possible operators Draft:\nWithin the currentEnvironment Nevent When one (or any) parameter in the currentEnvironment changes:\n Play an event (from an EventPattern / EventStream) \u0026lt;@ Play a synth from a SynthPlayer \u0026lt;+  Within an EventStreamPlayer playing within an Nevent (with Event @)  Play an event (from an EventPattern / EventStream) Evaluate a function  General principle: 4 types of objects stored under names in environments. Function:play: {} +\u0026gt;.envir \\playerName // Start a synth and store it in \\synth1 { SinOsc.ar(\\freq.kr(400), 0, \\amp.kr(0.1)) } +\u0026gt; \\synth1; //: Start a routine modifying the freq parameter { loop { ~freq = 50 rrand: 100; 5.1.wait; } } rout: \\envir; //: Replace the function playing in \\synth1 { Ringz.ar (WhiteNoise.ar (\\amp.kr (0.1)), \\freq.kr (400)) } +\u0026gt; \\synth1; //: Start a synth in a different environment { LFSaw.ar(\\freq.kr(400), 0, \\amp.kr(0.1)) } +\u0026gt;.envir2 \\synth1; //: Start a routine modifying the freq parameter in the second environment { loop { ~freq = 400 rrand: 4000; 0.1.wait; } } rout: \\envir2; //: Test the contents of the library Library.global.dictionary;  Accessing SynthPlayers, EventPatterns/EventStreamPlayers, Routines and Windows The following messages are used to access a SynthPlayer, EventStreamPlayer, Routine or Window stored under a name in an environment. If no enviroment is specified, then the currentEnvironment is used.\n symbol.synth(optional: envir) symbol.pattern(optional: envir) symbol.routine(optional: envir) symbol.window(optional: envir)  Additionally, the following introspection methods are provided:\n Nevent:envirs : Dictionary with all Nenvirs stored in Library under \\environments Registry;envirs : Synonym of Nevent:envirs \\envirName.synths : All synth players of Nenvir named \\envirName. \\envirName.patterns : All EventStreamPlayers of Nenvir named \\envirName. \\envirName.routines : All Routines of Nenvir named \\envirName. \\envirName.windows : All windows of Nenvir named \\envirName.  Method implementation code The code implementing these methods for Symbol in Nevent.sc is:\n// Return nil if no element found. // Also, do not push the environment if created. synth { | envir | ^Registry.at (envir.asEnvironment (false), \\synths, this); } pattern { | envir | ^Registry.at (envir.asEnvironment (false), \\patterns, this); } routine { | envir | ^Registry.at (envir.asEnvironment (false), \\routines, this); } window { | envir, rect | // always construct new window, and push the environment ^Registry (envir.asEnvironment, \\windows, this, { Window (this, rect) .onClose_ ({ | me | me.objectClosed; }); }) }  Tests //: explicitly push \\envir as currentEnvironment (only for clarity). \\envir.push; //: Initially, no synth is available: \\envir.synths; //: Also no synth is available in //: Play a function in envir: { PinkNoise.ar(0.2) } +\u0026gt;.envir \\test;  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/operators/",
	"title": "Operators",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/operators/",
	"title": "Operators",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/pattern/",
	"title": "Pattern",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/use-scenarios/patternsynthplay/",
	"title": "Pattern and Synth play scenarios",
	"tags": ["use,", "design,", "pattern,", "synth"],
	"description": "",
	"content": "Event:eplay and SynthPlayer can play with several instances in parallel on the same environment, and also provide several additional features. This section gives some examples that explore these features and show how they work and notes some questions regarding future features.\nCreating, starting and stopping patterns Playing several patterns in the same environment Playing several synths in the same environment "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/patterns/eventeplay/",
	"title": "Patterns updating current environment",
	"tags": ["notification,", "EnvGen,", "trigger,", "EventPattern,", "Event"],
	"description": "",
	"content": "anEnvironment.eplay(envir)\nPlay an event as EventPattern, updating the values in envir from each event. Use custom event type: envEvent. This only updates the values in the environment. The sound must be generated by Function:eplay. See examples below.\nPlay the receiver Event in the environment given in argument envir using a custom event type to just set the values of corresponding variables at each event. For example, playing () set ~freq to 60.midicps every 1 second.\n(dur: 0.1).eplay;  ().eplay;  () eplay: \\newEnvir;  Examples Example 1: Single synth, pattern, gui update (degree: Pbrown (0, 30, 2, inf), dur: 0.1).eplay; { | freq = 400 | SinOsc.ar (freq, 0, 0.1 )}.eplay; \\window.vlayout (CSlider (\\freq)).front;  Example 2: Envelope gate on-off To test triggering of envelopes, instead of writing this:\n{ | freq = 400, gate = 0 | var env; env = Env.adsr (); SinOsc.ar (freq, 0, 0.1) ,* EnvGen.kr (env, gate: gate, doneAction: 0) }.eplay; //: { inf do: { | i | ~gate = i % 2; 0.1.rrand (0.5).wait } }.rout;  one may write this:\n{ | freq = 400, gate = 0 | var env; env = Env.adsr (0.01, 0.01, 0.9, 0.3); SinOsc.ar (freq, 0, 0.1) ,* EnvGen.kr (env, gate: gate, doneAction: 0) }.eplay; (dur: Pwhite (0.01, 0.15, inf), gate: Pseq([0, 1], inf)).eplay; //: Note the overlap with the still playing note in the freq change: (dur: 0.15, gate: Pseq([0, 1], inf), degree: Pstutter (4, Pbrown (-5, 20, 5, inf))).eplay;  Example 3: Many patterns + many synths in same environment { | freq = 400 | SinOsc.ar (freq * [1, 1.25], 0, 0.1) }.eplay; (dur: 0.1, degree: Pbrown (-1, 20, 2, inf)).eplay; //: Start the next synth later: { | freq = 400 | Ringz.ar (PinkNoise.ar, freq * 1.2) }.eplay (\\synth2); //: Test fade out when releasing synth to replace with new one: ~fadeTime = 5; //: { | freq = 400, ringTime = 3 | Ringz.ar (PinkNoise.ar, freq * [2, 1.2], ringTime) }.eplay (\\synth2); //: ~ringTime = 0.03; //: ~ringTime = 2; //: Start a new pattern in place of the old one: (dur: 0.1, degree: Pbrown (-1, 20, 2, inf), ringTime: Pwhite (0.01, 1.2, inf)).eplay; //: remove the ringTime from the next version of the pattern: (dur: 0.1, degree: Pbrown (-1, 20, 2, inf)).eplay; //: add a new pattern on the same environment, playing ringTime: (dur: 0.01, ringTime: Pbrown (0.001, 3, 0.1, inf)).eplay (\\ringTime);`` //: add a new pattern on the same environment, playing ringTime: (dur: 0.1, ringTime: Pwhite (0.01, 4, inf)).eplay (\\ringTime); //:  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/synths/function-eplay/",
	"title": "Play a function in the environment",
	"tags": ["synth,", "method,", "environment"],
	"description": "",
	"content": " Provide arguments for playing a function from values found in an environment. connect all control names in the function's arguments to an environment for auto-update Free all notifications from the synth when it stops playing.  Method code + Function { eplay { | envir = \\envir | var synth; envir = envir.asEnvironment; envir use: { var argNames, args; argNames = this.def.argNames; args = argNames.collect ({ | name | [name, currentEnvironment [name]] }).select ({ | pair | pair [1].notNil; }).flat; // arg target, outbus = 0, fadeTime = 0.02, addAction=\\addToHead, args; synth = this.play ( ~target.asTarget, ~outbus ? 0, ~fadeTime ? 0.02, ~addAction ? \\addToHead, args ); argNames do: { | param | synth.addNotifier (envir, param, { | val | synth.set (param, val); }); }; }; // This is done by addNotifier anyway: //\tsynth.onEnd (this, { synth.objectClosed }); ^synth; } }  Example \\window.vlayout ( HLayout ( StaticText ().string_ (\\freq), Slider.horizontal.connectEnvir (\\freq), NumberBox ().connectEnvir (\\freq) ) ).front; //: { loop { ~freq = 400 + 400.rand; 1.wait; } }.fork; //: { | freq = 440 | SinOsc.ar (freq, 0, 0.1) }.eplay; //:  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/patterns/playingeventsaspatterns/",
	"title": "Playing Events as Patterns",
	"tags": ["Event,", "Pattern"],
	"description": "",
	"content": " /sc-hacks/ provides two ways to play Events as patterns: \\name pplay: (event ...) Play event as EventPattern, using default play key settings, i.e. playing notes unless something else is specified. (event ...) eplay: \\name Play event as EventPattern using a custom partial event type \\envEvent. This does not produce any sounds per default, but only writes the results of playing all streams in the event, including the default translations of \\degree, \\ctranspose and related keys, to currentEnvironment. These changes are broadcast to the system using the changed mechanism and can be used to drive both GUI and synths.  Both pplay and eplay use EventPattern, EventStream and EventStreamPlayer. This means, it is easy to modify the event and thus change the behaviour of the player, while it is playing.\nSymbol pplay Here the pattern is modified with addKey, addEvent and setEvent while playing:\n\\p.pplay; //: \\p.pplay ((freq: Pbrown (10, 200, 10, inf) * 10)); //: \\p.pplay ((degree: Pbrown (1, 20, 3, inf))); //: \\p.addKey (\\dur, 0.1); //: \\p addEvent: (ctranspose: Pstutter (20, Pbrown (-6, 6, 1, inf)), legato: Pseq ([0.2, 0.1, 0.2, 4], inf)); //: \\p setEvent: (freq: Pwhite (300, 3000, inf), dur: Pseq ([0.1, 0.3], inf), legato: 0.1);  Event eplay (freq: Pwhite (400, 20000, inf).sqrt, dur: 0.1).eplay; \\window.vlayout (CSlider (\\freq)).front; //: (freq: Pwhite (400, 2000, inf), dur: 0.1).eplay; //: \\test splay: { SinOsc.ar (\\freq.kr (400), 0, 0.1) }; //: (degree: Pbrown (0, 20, 2, inf), dur: 0.1).eplay; //: Play different functions in parallel, with crossfade: ~fadeTime = 2; { var players; players = Pseq ([ { LFPulse.ar (\\freq.kr (400) / [2, 3], 0, 0.5, 0.1) }, /* { Blip.ar (\\freq.kr (400 * [1, 1.2]), LFNoise0.kr (5).range (5, 250), 0.3) }, ,*/ { LPF.ar ( Ringz.ar (PinkNoise.ar (0.1), \\freq.kr (400) * [1, 1.5], 0.1), LFNoise2.kr (1).range (400, 1000) ) } ], inf).asStream; loop { \\test splay: players.next; 2.5.wait; } }.fork; //: NOTE: other keys are overwritten in the source event of the other  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/exploring-techniques/playinggrains/",
	"title": "Playing Grains",
	"tags": ["granular", "synthesis"],
	"description": "",
	"content": "Here are some examples for playing grains of sound from a buffer with\nTo be provided ...\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/exploring-techniques/playingwithdata/",
	"title": "Playing With Data",
	"tags": ["data,", "design"],
	"description": "",
	"content": "This section discusses problems and approaches for sonifying data using EventPlayer and SynthPlayer.\nData dimensions and play method The data is a 2 dimensional array. It is played as a Pseq along the first dimension. This results in a stream of rows. Each subsequent element returned by the stream is a row of data.\nDifferent ways of playing rows Playing each data row as one Synth Playing each d "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/registry/",
	"title": "Registry",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/foundation-classes/registry/",
	"title": "Registry: Hierarchical Namespaces",
	"tags": ["registry"],
	"description": "",
	"content": "This class uses the Library class to store and retrieve objects using any array of objects as key. This extends the way that Pdef, Ndef, OSCdef work, making it possible for any class to store its instances in an arbitrary hierarchical path, without subclassing. To create this behavior one can then add a method to Symbol for accessing the kind of object needed. For example: \\aSymbol.oscFunc accesses OSCFunc instances. This also allows easier customization of how the object is created if not found.\nHow it works Store an object in Library under an array of objects (called a path). When accessing the path, create the object if not already stored, else return the previously stored object.\nWho uses it  SynthPlayer registers its instances in the current environment under their names. - Function:oscFunc and Symbol:removeOsc registers OSCFuncs under their path names in order to remove existing OSCFunc instances when creating a new one under the same path.   Example This is the code that makes it possible to create or modify an OSCFunc bound to a symbol. It defines the methods Function:oscFunc and Symbol:removeOsc.\n+ Function { oscFunc { | path | path.removeOsc; ^Registry ('oscFuncs', path, { OSCFunc (this, path) }); } } + Symbol { removeOsc { Registry.doIfFound ('oscFuncs', this, { | found | found.objectClosed; found.free; });\t} }  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/basic-principles/principles/storespecsandsynthdefsinlibrary/",
	"title": "Store Specs and SynthDefs in Library",
	"tags": ["TODO,", "design"],
	"description": "",
	"content": "Specs and SynthDefs should be stored in Library using Registry. Advantages:\n simplify and unify the API for accessing Specs and SynthDefs (and SynthDescs). provide global access to Specs and SynthDefs for all environments, guis, synths using spec/synthdef name. ensure SynthDefs are always loaded when the server is rebooted, also when it is a remote server. provide easy global access to SynthDescs for automatic GUI generation.  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/synth/",
	"title": "Synth",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/synthesis/",
	"title": "Synthesis",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/techniques/",
	"title": "Techniques",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tests/slide-test/",
	"title": "Test slide",
	"tags": [],
	"description": "",
	"content": " This is a slide test This is content\nThis is the second section This is the content of the second section.\nThis is the third section The slide should appear below somehow.\nEmbedding mermaid does not work\nJavascript works as code.  quote and un-quote. italics bold\n"
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/todo/",
	"title": "Todo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/trigger/",
	"title": "Trigger",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/exploring-techniques/triggeringenvgen/",
	"title": "Triggering EnvGen and Line",
	"tags": ["design,", "envgen,", "env,", "trigger,", "gate"],
	"description": "",
	"content": "Besides controlling the amplitude shape of a single sound-event or note in its entirety, envelopes can also be used to generate streams of sound events with the same synth. The same technique can also be applied to Line or Xline to arbitrarily construct shapes controlling any parameter on the fly. Here are some examples explaining how to do this using either just the default SCClassLibrary and the sc-hacks library.\nBasic Examples  Two items are necessary to re-trigger envelope or line-segment UGens in a Synth: The doneAction argument of the UGen in question must have a value of 0 in order to keep the Synth alive afer the UGen has finished playing. The UGen in question must use a control in its gate argument. The UGen restarts whenever the value of the gate control changes from 0 to 1. Furthermore, if the Envelope contains a release part, then the release part will be triggered when the gate control changes from 1 to 0.  Caution: Use a name other than gate as control name for triggering *NOTE: The control used to trigger the EnvGen must have a name different than gate, otherwise SC will be unable to release the synth because it creates a second gate control by default when creating synthdefs from functions. For example:\n//: This is wrong: a = { | freq = 400, gate = 0 | var env; env = Env.adsr (); SinOsc.ar (freq, 0, 0.1) ,* EnvGen.kr (env, gate: gate, doneAction: 0) }.play; NodeWatcher.register (a); // register a to update state when it ends //: Test if a is playing a.isPlaying; // first let it make a sound: a.set (\\gate, 1); //: then try to release it: a.release; //: The output amplitude is 0 but the synth is still playing: a.isPlaying; //: Try again, specifying a release time: a.release (0.1); //: To really stop the synth, you have to free it a.free; //: The synth has stopped playing. Synth count should be 0 in the server display a.isPlaying; // returns false  Function play and Synth set (SCClassLibrary) Here is a simple example using only the standard SCClassLibrary:\n//: Start a triggerable synth and store it in variable a // Note: The EnvGen will not be triggered because trig is 0. // Thus the synth will not produce an audible signal. // use trig instead of gate as control name! a = { | freq = 400, trig = 0 | var env; env = Env.adsr (); SinOsc.ar (freq, 0, 0.1) ,* EnvGen.kr (env, gate: trig, doneAction: 0) }.play; //: Trigger the envelope a.set (\\trig, 1); //: Release the envelope a.set (\\trig, 0); //: Re-trigger the nevelope a.set (\\trig, 1); //: Release the envelope again a.set (\\trig, 0); //: Run a routine to start and stop the synth several times { 10 do: { | i | a.set (\\trig, (i + 1) % 2); // i+1 : start with trigger on 0.01.exprand (0.5).wait; } }.fork; //: Do the same as above, but also change the frequency { 40 do: { | i | // only change frequency when starting, not when releasing: if (i + 1 % 2 \u0026gt; 0) { // i / 2: wholetone -\u0026gt; chromatic a.set (\\freq, (i / 2 + 60).midicps, \\trig, 1);\t}{ a.set (\\trig, 0); }; 0.01.exprand (0.5).wait; }; }.fork; //:  Control through environment variables, using Function +\u0026gt; In sc-hacks, the operator +\u0026gt; plays a function and stores its synth in the global Library using a SynthPlayer instance. Additionally, it makes the synth react whenever an environment variable whose name corresponds to a control parameter of the synth is set in the currentEnvironment. This makes it easy to control the synth through the environment.\nExample:\n{ | freq = 400, trig = 0 | var env; env = Env.adsr (); SinOsc.ar (freq, 0, 0.1) ,* EnvGen.kr (env, gate: trig, doneAction: 0) } +\u0026gt; \\test; //: ~trig = 1; //: ~trig = 0; //: { var trig; inf do: { | i | trig = i + 1 % 2; if (trig \u0026gt; 0) { ~freq = 300 rrand: 3000 }; ~trig = trig; 0.9.rand.wait; }; }.rout; // rout starts a routine like fork, and stores it in the library // under a name (default: 'routine') // Additionally, if a routine is running under the same name, // it stops that routine before starting the new one to replace it. //: { var trig; 26 do: { | i | trig = i + 1 % 2; if (trig \u0026gt; 0) { ~freq = (i / 2 + 60).midicps }; ~trig = trig; 0.24.wait; }; }.rout; //: { 20 do: { | i | ~trig = i + 1 % 2; ~freq = 300 rrand: 3000; 0.9.rand.wait; } }.rout;  "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/exploring-techniques/triggeringmethods/",
	"title": "Triggering Methods",
	"tags": ["trigger,", "gate,", "techniques,", "grains,", "envelopes"],
	"description": "",
	"content": "This section illustrates several different ways to trigger grains, envelopes or other gate-triggered UGens\nTriggering from lang with set Triggering internally UGens Impulse, Dust etc. Demand UGens "
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/categories/use/",
	"title": "Use",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/use/",
	"title": "Use",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iani.github.io/sc-hacks-hugodoc/tags/window/",
	"title": "Window",
	"tags": [],
	"description": "",
	"content": ""
}]